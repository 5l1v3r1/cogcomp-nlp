package edu.illinois.cs.cogcomp.comma.lbj;
import edu.illinois.cs.cogcomp.comma.Comma;
import edu.illinois.cs.cogcomp.comma.Sentence;
import edu.illinois.cs.cogcomp.comma.CommaReader;
import edu.illinois.cs.cogcomp.edison.sentences.Constituent;
import edu.illinois.cs.cogcomp.edison.sentences.ViewNames;
import edu.illinois.cs.cogcomp.edison.sentences.Relation;
import edu.illinois.cs.cogcomp.edison.sentences.PredicateArgumentView;
import java.util.List;
import java.util.ArrayList;

discrete UnigramLeftFeature(Comma c) <- {
    return c.getWordToLeft(1);
}

discrete UnigramSecondLeftFeature(Comma c) <- {
	return c.getWordToLeft(2);
}

discrete UnigramRightFeature(Comma c) <- {
    return c.getWordToRight(1);
}

discrete UnigramSecondRightFeature(Comma c) <- {
	return c.getWordToRight(2);
}



discrete UnigramLeftPOSFeature(Comma c) <- {
    return c.getPOSToLeft(1);
}

discrete UnigramSecondLeftPOSFeature(Comma c) <- {
    return c.getPOSToLeft(2);
}

discrete UnigramRightPOSFeature(Comma c) <- {
    return c.getPOSToRight(1);
}

discrete UnigramSecondRightPOSFeature(Comma c) <- {
    return c.getPOSToRight(2);
}



discrete UnigramLeftChunkFeature(Comma c) <- {
    return Comma.getNotation(c.getChunkToLeftOfComma(1));
}

discrete UnigramSecondLeftChunkFeature(Comma c) <- {
  return Comma.getNotation(c.getChunkToLeftOfComma(2));
}

discrete UnigramRightChunkFeature(Comma c) <- {
    return Comma.getNotation(c.getChunkToRightOfComma(1));
}

discrete UnigramSecondRightChunkFeature(Comma c) <- {
  return Comma.getNotation(c.getChunkToRightOfComma(2));
}



discrete UnigramLeftPhraseFeature(Comma c) <- {
    return Comma.getNotation(c.getPhraseToLeftOfComma(1));
}

discrete UnigramSecondLeftPhraseFeature(Comma c) <- {
  return Comma.getNotation(c.getPhraseToLeftOfComma(2));
}

discrete UnigramRightPhraseFeature(Comma c) <- {
    return Comma.getNotation(c.getPhraseToRightOfComma(1));
}

discrete UnigramSecondRightPhraseFeature(Comma c) <- {
  return Comma.getNotation(c.getPhraseToRightOfComma(2));
}

discrete CommaParentFeature(Comma c) <- {
    return Comma.getNotation(c.getPhraseToLeftOfParent(0));
}

discrete UnigramParentLeftPhraseFeature(Comma c) <- {
    return Comma.getNotation(c.getPhraseToLeftOfParent(1));
}

discrete UnigramParentSecondLeftPhraseFeature(Comma c) <- {
  return Comma.getNotation(c.getPhraseToLeftOfParent(2));
}

discrete UnigramParentRightPhraseFeature(Comma c) <- {
    return Comma.getNotation(c.getPhraseToRightOfParent(1));
}

discrete UnigramParentSecondRightPhraseFeature(Comma c) <- {
  return Comma.getNotation(c.getPhraseToRightOfParent(2));
}



discrete% SRLFeature(Comma c) <- {
    List SRLs = c.getContainingSRLs();
    for (int i = 0; i < SRLs.size(); i++) {
        String s = (String) SRLs.get(i);
        sense s;
    }
}


discrete ParseTreeFeature(Comma c) <- {
    String tree = "";
    int distance = 0;
    String phrase;
    do{
      phrase = Comma.getNotation(c.getPhraseToLeftOfParent(distance));
      tree = phrase + tree;
      distance++;
    }while(!phrase.equals("NULL"));

    String commaLevelPhrases = "";
    distance = 0;
	do{
      phrase = Comma.getNotation(c.getPhraseToLeftOfComma(distance));
      commaLevelPhrases =  phrase + commaLevelPhrases;
      distance++;
    }while(!phrase.equals("NULL"));
    
	distance = 1;
    do{
      phrase = Comma.getNotation(c.getPhraseToRightOfComma(distance));
      commaLevelPhrases = commaLevelPhrases + phrase;
      distance++;
    }while(!phrase.equals("NULL"));
	tree += "(" + commaLevelPhrases + ")";

    distance = 1;
    do{
      phrase = Comma.getNotation(c.getPhraseToRightOfParent(distance));
      tree = tree + phrase;
      distance++;
    }while(!phrase.equals("NULL"));
    
    return tree;
}



discrete BigramLeftPhraseFeature(Comma c) <- UnigramSecondLeftPhraseFeature && UnigramLeftPhraseFeature

discrete BigramRightPhraseFeature(Comma c) <- UnigramSecondRightPhraseFeature && UnigramRightPhraseFeature

discrete BigramParentLeftPhraseFeature(Comma c) <- UnigramParentSecondLeftPhraseFeature && UnigramParentLeftPhraseFeature

discrete BigramParentRightPhraseFeature(Comma c) <- UnigramParentSecondRightPhraseFeature && UnigramParentRightPhraseFeature


discrete% ParseParentFeatures(Comma c) <- CommaParentFeature, UnigramParentLeftPhraseFeature, UnigramParentSecondLeftPhraseFeature, UnigramParentRightPhraseFeature, UnigramParentSecondRightPhraseFeature

discrete% ParseFeatures(Comma c) <- UnigramSecondLeftPhraseFeature, UnigramSecondRightPhraseFeature, UnigramLeftPhraseFeature, UnigramRightPhraseFeature

discrete% BigramParseFeatures(Comma c) <- BigramLeftPhraseFeature, BigramRightPhraseFeature, BigramParentLeftPhraseFeature, BigramParentRightPhraseFeature

discrete% POSFeatures(Comma c) <- UnigramSecondLeftPOSFeature, UnigramSecondRightPOSFeature, UnigramLeftPOSFeature, UnigramRightPOSFeature

discrete CommaLabel(Comma c) <- { return c.getRole(); }

/** A learned text classifier; its definition comes from data. */
discrete LocalCommaClassifier(Comma c) <-
learn CommaLabel
  using ParseFeatures, ParseParentFeatures, POSFeatures, ParseTreeFeature, BigramParseFeatures

  from new CommaReader("data/comma_resolution_data.txt", "data/CommaTAGoldFinal.ser")
  100 rounds
  cval 5 "random"

  with SparseNetworkLearner {
    SparseAveragedPerceptron.Parameters p = new SparseAveragedPerceptron.Parameters();
    p.learningRate = .1;
    p.thickness = 3;
    baseLTU = new SparseAveragedPerceptron(p);
  }
  //evaluate discreteValue(c)


  testingMetric new PrintMetrics(5)
  
  preExtract "false"
	
  progressOutput 0
end



constraint substitutePairFirstComma (Sentence s)
{
	forall (Comma c in s.getFirstCommasWhichAreNotLast())
		((LocalCommaClassifier(c) :: "Substitute") => (LocalCommaClassifier(s.getNextComma(c)) :: "Substitute"));
}

constraint substitutePairMiddleCommas (Sentence s)
{
	forall (Comma c in s.getMiddleCommas())
		((LocalCommaClassifier(c) :: "Substitute") => 
												((LocalCommaClassifier(s.getNextComma(c)) :: "Substitute")
												\/(LocalCommaClassifier(s.getPreviousComma(c)) :: "Substitute")));
}

//substitute commas must occur in pairs or must be the last comma in the sentence.
constraint substitutePair (Sentence s)
{
	(@substitutePairFirstComma(s) /\ @substitutePairMiddleCommas(s));
}







constraint locativePairFirstComma (Sentence s)
{
	forall (Comma c in s.getFirstCommasWhichAreNotLast())
		((LocalCommaClassifier(c) :: "Locative") => (LocalCommaClassifier(s.getNextComma(c)) :: "Locative"));
}


constraint locativePairMiddleCommas (Sentence s)
{
	forall (Comma c in s.getMiddleCommas())
		((LocalCommaClassifier(c) :: "Locative") => 
												((LocalCommaClassifier(s.getNextComma(c)) :: "Locative")
												\/(LocalCommaClassifier(s.getPreviousComma(c)) :: "Locative")));
}

//one exception is "champaign, IL, USA". Here the 2 commas are for two different located in's as compared to "Champaign, IL, is a nice city" where the 2 commas are for one 'located in'
constraint locativePair (Sentence s)
{
	@locativePairFirstComma(s) /\ @locativePairMiddleCommas(s);
}


//if a comma is followed by an 'and', it is a list comma
//can't simply check for next POS tag to be a CC. conflicts with wsj 0015mrg 8 substitute
constraint oxfordComma (Sentence s)
{
	forall (Comma c in s.getCommas())
		((UnigramRightFeature(c) :: "and") => 
											(LocalCommaClassifier(c) :: "List"));
}


//if the commas on either side of a comma are list commas it is a list comma?
constraint listCommas (Sentence s)
{
	forall (Comma c in s.getMiddleCommas())
		(((LocalCommaClassifier(s.getPreviousComma(c)) :: "List") 
		 /\(LocalCommaClassifier(s.getNextComma(c)) :: "List")) =>
																	(LocalCommaClassifier(c) :: "List"));
}

inference JointCommaSRL head Sentence s {
	Comma c {return c.getSentence();}
	subjectto {@oxfordComma(s) /\ @substitutePair(s);}
	//subjectto {@oxfordComma(s) /\ @substitutePairFirstComma(s) /\ @substitutePairMiddleCommas(s);}
	//subjectto {@substitutePair(s) /\ @locativePair(s) /\ @oxfordComma(s) /\ @listCommas(s);}
	with new ILPInference(new GurobiHook())
}

discrete JointCommaClassifier (Comma c) <- 
	JointCommaSRL(LocalCommaClassifier)
